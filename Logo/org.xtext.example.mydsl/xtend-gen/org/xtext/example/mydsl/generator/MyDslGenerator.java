/**
 * generated by Xtext 2.13.0
 */
package org.xtext.example.mydsl.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterators;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.xtext.example.mydsl.myDsl.CMD;
import org.xtext.example.mydsl.myDsl.LEFT;
import org.xtext.example.mydsl.myDsl.MOVE;
import org.xtext.example.mydsl.myDsl.PAPER;
import org.xtext.example.mydsl.myDsl.PENCOLOUR;
import org.xtext.example.mydsl.myDsl.PENSTATE;
import org.xtext.example.mydsl.myDsl.RIGHT;
import org.xtext.example.mydsl.myDsl.TURTLE;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class MyDslGenerator extends AbstractGenerator {
  private double paperInitWidth;
  
  private double paperInitHeight;
  
  private double TurtleOrientation = 0;
  
  private boolean brushState = true;
  
  private double turtleX;
  
  private double turtleY;
  
  private double newX;
  
  private double newY;
  
  private boolean changeMade;
  
  private String colour = "black";
  
  private String paperColour = "white";
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("<!DOCTYPE html>");
    _builder.newLine();
    _builder.append("<html>");
    _builder.newLine();
    _builder.append("<body>");
    _builder.newLine();
    this.setPaper(IteratorExtensions.<PAPER>head(Iterators.<PAPER>filter(Iterators.<CMD>filter(resource.getAllContents(), CMD.class), PAPER.class)));
    _builder.newLineIfNotEmpty();
    _builder.append("<svg height=\"");
    _builder.append(this.paperInitHeight);
    _builder.append("\" width=\"");
    _builder.append(this.paperInitWidth);
    _builder.append("\">");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("<rect width=\"");
    _builder.append(this.paperInitWidth, "\t");
    _builder.append("\" height=\"");
    _builder.append(this.paperInitHeight, "\t");
    _builder.append("\" style=\"fill:");
    _builder.append(this.paperColour, "\t");
    _builder.append("\"/>");
    _builder.newLineIfNotEmpty();
    {
      Iterable<CMD> _iterable = IteratorExtensions.<CMD>toIterable(Iterators.<CMD>filter(resource.getAllContents(), CMD.class));
      for(final CMD c : _iterable) {
        _builder.newLine();
        boolean _matched = false;
        if (c instanceof TURTLE) {
          if (Objects.equal(c, ((TURTLE)c))) {
            _matched=true;
            this.setTurtle(((TURTLE)c));
          }
        }
        if (!_matched) {
          if (c instanceof PENCOLOUR) {
            if (Objects.equal(c, ((PENCOLOUR)c))) {
              _matched=true;
              this.setColour(((PENCOLOUR)c));
            }
          }
        }
        if (!_matched) {
          if (c instanceof PENSTATE) {
            if (Objects.equal(c, ((PENSTATE)c))) {
              _matched=true;
              this.changePenState(((PENSTATE)c));
            }
          }
        }
        if (!_matched) {
          if (c instanceof RIGHT) {
            if (Objects.equal(c, ((RIGHT)c))) {
              _matched=true;
              this.rotateTurtleRight(((RIGHT)c).getAmount());
            }
          }
        }
        if (!_matched) {
          if (c instanceof LEFT) {
            if (Objects.equal(c, ((LEFT)c))) {
              _matched=true;
              this.rotateTurtleLeft(((LEFT)c).getAmount());
            }
          }
        }
        if (!_matched) {
          if (c instanceof MOVE) {
            if (Objects.equal(c, ((MOVE)c))) {
              _matched=true;
              this.move(((MOVE)c).getAmount());
            }
          }
        }
        _builder.newLineIfNotEmpty();
        _builder.newLine();
        {
          if ((this.changeMade && this.brushState)) {
            _builder.append("<line x1=\"");
            _builder.append(this.turtleX);
            _builder.append("\" y1=\"");
            _builder.append(this.turtleY);
            _builder.append("\" x2=\"");
            _builder.append(this.newX);
            _builder.append("\" y2=\"");
            _builder.append(this.newY);
            _builder.append("\" style=\"stroke:");
            _builder.append(this.colour);
            _builder.append(";stroke-width:2\" />");
            _builder.newLineIfNotEmpty();
            this.resetco();
            _builder.newLineIfNotEmpty();
          } else {
            this.resetco();
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.newLine();
      }
    }
    _builder.append("Sorry, your browser does not support inline SVG.");
    _builder.newLine();
    _builder.append("</svg>");
    _builder.newLine();
    _builder.append("</body>");
    _builder.newLine();
    _builder.append("</html>");
    _builder.newLine();
    fsa.generateFile("turtle.html", _builder);
  }
  
  public void setColour(final PENCOLOUR c) {
    this.colour = c.getColour().toLowerCase();
  }
  
  public void setPaper(final PAPER c) {
    this.changeMade = false;
    this.paperInitWidth = c.getSizeX();
    this.paperInitHeight = c.getSizeY();
    this.paperColour = c.getPaperColour().toLowerCase();
  }
  
  public void setTurtle(final TURTLE c) {
    this.changeMade = false;
    this.turtleX = c.getStartPosX();
    this.turtleY = c.getStartPosY();
    this.newX = this.turtleX;
    this.newY = this.turtleY;
  }
  
  public void rotateTurtleRight(final int angle) {
    this.changeMade = false;
    double _TurtleOrientation = this.TurtleOrientation;
    double _plus = this.TurtleOrientation = (_TurtleOrientation + angle);
    double _modulo = (_plus % 360);
    this.TurtleOrientation = _modulo;
  }
  
  public void rotateTurtleLeft(final int angle) {
    this.changeMade = false;
    this.TurtleOrientation = (((360 + this.TurtleOrientation) - angle) % 360);
  }
  
  public void resetco() {
    this.turtleX = this.newX;
    this.turtleY = this.newY;
    this.changeMade = false;
  }
  
  public void changePenState(final PENSTATE s) {
    this.changeMade = false;
    boolean _equals = s.getPenState().equals("UP");
    if (_equals) {
      this.brushState = false;
    } else {
      this.brushState = true;
    }
  }
  
  public void move(final int amount) {
    double _sin = Math.sin((this.TurtleOrientation * (Math.PI / 180)));
    double _multiply = (amount * _sin);
    double _plus = (this.turtleX + _multiply);
    this.newX = Math.round(_plus);
    double _cos = Math.cos((this.TurtleOrientation * (Math.PI / 180)));
    double _multiply_1 = (amount * _cos);
    double _minus = (this.turtleY - _multiply_1);
    this.newY = Math.round(_minus);
    this.changeMade = true;
  }
}
